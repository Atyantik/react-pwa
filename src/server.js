import express from "express";
import serveFavicon from "serve-favicon";
import path from "path";
import fs from "fs";
import cookieParser from "cookie-parser";
import compression from "compression";
import _ from "lodash";
import React from "react";
import ReactDOMServer from "react-dom/server";
import {
  StaticRouter as ServerRouter,
  Route as ServerRoute,
  Switch as ServerSwitch,
} from "react-router";
import Config from "config";

import {
  extractFilesFromAssets,
  getModuleByPathname,
  getRouteFromPath
} from "utils/bundler";

import {
  getPreloadDataPromises,
  renderRoutesByUrl,
  renderNotFoundPage,
  renderErrorPage,
} from "utils/renderer";

import Storage from "lib/storage";
import Api from "lib/api";
import Routes  from "./routes";
import Html from "app/components/html";

// Create and express js application
const app = express();

// use compression for all requests
app.use(compression());

let currentDir = __dirname;

if (process.env.NODE_ENV === "production") {
  const filename = _.find(process.argv, arg => {
    return arg.indexOf("/server.js") !== -1;
  });
  if (filename) {
    currentDir = path.dirname(filename);
  }
}

const faviconPath = path.resolve(path.join(currentDir, "public", "favicon.ico"));
if (fs.existsSync(faviconPath)) {
  app.use(serveFavicon(path.join(currentDir, "public", "favicon.ico")));
}

// Extract cookies from the request
app.use(cookieParser());

// Set x-powered-by to false (security issues)
_.set(app, "locals.settings.x-powered-by", false);

// Add public path to server from public folder
// This is used when doing server loading
app.use("/public", express.static(path.join(currentDir, "public")));

// Middleware to add assets to request
try {
  const assets = require("./config/assets").default;
  app.use(function (req, res, next) {
    req.assets = assets;
    next();
  });
} catch (ex) {
  // Do not do anything here.
  // cause the assets are most probably handled by webpack in dev mode
}
const getErrorComponent = (err) => {
  if (!(err instanceof Error)) {
    err = new Error(err);
  }
  err.statusCode = err.statusCode || 500;
  return renderErrorPage({
    render: false,
    Router: ServerRouter,
    Route: ServerRoute,
    Switch: ServerSwitch,
    error: err,
  });
};

export default app;

export const startServer = () => {

  /**
   * Send global data to user, as we do not want to send it via
   * window object
   */
  app.get("/_globals", (req,res) => {

    // Never ever cache this request
    const { assets } = req;
    const allCss = extractFilesFromAssets(assets, ".css");
    const allJs = extractFilesFromAssets(assets, ".js");

    res.setHeader("Content-Type", "application/json");
    // No cache header
    res.setHeader("Cache-Control", "private, no-cache, no-store, must-revalidate");
    res.setHeader("Expires", "-1");
    res.setHeader("Pragma", "no-cache");

    return res.send(JSON.stringify({ routes: Routes, allCss, allJs }));
  });

  app.get("*", (req, res) => {
    let routes = _.assignIn({}, Routes);

    // Get list of assets from request
    const { assets } = req;

    /**
     * Get all css and js files for mapping
     */
    const allCss = extractFilesFromAssets(assets, ".css");
    const allJs = extractFilesFromAssets(assets, ".js");

    let mod = getModuleByPathname(routes, req.path);
    const currentRoutes = getRouteFromPath(routes, req.path);

    const storage = new Storage(req, res);
    const api = new Api({storage});

    /**
     * Get css generated by current route and module
     */
    const currentRouteCss = _.filter(allCss, css => {
      const fileName = css.split("/").pop();
      return !(_.startsWith(fileName, "mod-") && fileName.indexOf(mod) === -1);
    });

    /**
     * Get all javascript but the modules
     */
    const currentRouteJs = _.filter(allJs, js => {
      const fileName = js.split("/").pop();
      return !_.startsWith(fileName, "mod-");
    });

    const context = {
      storage,
      api
    };

    let html, statusCode = 200;

    // Get seo details for the routes in an inherited manner
    // i.e. get seo details of parent when feasible
    let seoDetails = {};
    let routerComponent = null;

    try {

      // Also preload data required when asked
      let promises = getPreloadDataPromises({
        routes,
        storage,
        api
      });

      Promise.all(promises).then(() => {

        // Once all data has been pre-loaded and processed
        _.each(currentRoutes, r => {
          seoDetails = _.defaults({}, _.get(r, "seo", {}), seoDetails);
        });

        if (!currentRoutes.length) {
          routerComponent = renderNotFoundPage({
            render: false,
            Router: ServerRouter,
            url: req.path,
            Switch: ServerSwitch,
            Route: ServerRoute,
            context: context,
          });
        } else {
          routerComponent = renderRoutesByUrl({
            render: false,
            Router: ServerRouter,
            url: req.path,
            Switch: ServerSwitch,
            Route: ServerRoute,
            context: context,
            routes: routes,
            storage,
            api
          });
        }

        statusCode = context.status || 200;
        if (context.url) {
          // Somewhere a `<Redirect>` was rendered
          return res.status(statusCode).redirect(context.url);
        }

        html = ReactDOMServer.renderToStaticMarkup((
          <Html
            stylesheets={currentRouteCss}
            scripts={currentRouteJs}
            seo={seoDetails}
          >
          {routerComponent}
          </Html>
        ));
        return res.status(statusCode).send(`<!DOCTYPE html>${html}`);

      }).catch((err) => {
        routerComponent = getErrorComponent(err);
        html = ReactDOMServer.renderToStaticMarkup((
          <Html
            stylesheets={currentRouteCss}
            scripts={currentRouteJs}
          >
          {routerComponent}
          </Html>
        ));
        return res.status(statusCode).send(`<!DOCTYPE html>${html}`);
      });
      // Get data to load for all the routes
    } catch (err) {
      routerComponent = getErrorComponent(err);
      html = ReactDOMServer.renderToStaticMarkup((
        <Html
          stylesheets={currentRouteCss}
          scripts={currentRouteJs}
        >
        {routerComponent}
        </Html>
      ));
      return res.status(statusCode).send(`<!DOCTYPE html>${html}`);
    }
  });

  app.listen(_.get(Config, "server.port", 3000), () => {
    // eslint-disable-next-line no-console
    console.log("App Started ==> Open http://localhost:3000 to see the app");
  });
};
